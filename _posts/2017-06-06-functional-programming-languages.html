---
layout: post
title: FUNCTIONAL PROGRAMMING LANGUAGES
date: '2017-06-06T05:08:00.000-07:00'
author: akshay kishore
tags: 
modified_time: '2017-06-06T05:08:05.082-07:00'
blogger_id: tag:blogger.com,1999:blog-940619237864642591.post-3863767223273143327
blogger_orig_url: http://akshaykishore.blogspot.com/2017/06/functional-programming-languages.html
---

<div dir="ltr" style="text-align: left;" trbidi="on"><h2 style="text-align: left;"><span style="color: purple;">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; FUNCTIONAL PROGRAMMING</span></h2><h2 style="text-align: left;"><span style="color: purple;">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; LANGUAGES</span></h2><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Hello guys,this blog is all about why we use &nbsp;functional programming rather than using traditional languages,what are all its types and its pros and cons .Let me explain in detail about it.</div><div><br /></div><div><br /></div><h3 style="text-align: left;"><span style="color: cyan;">WHAT IS FUNCTIONAL PROGRAMMING:</span></h3><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Functional programming is a paradigm which concentrates on computing results rather than on performing actions. &nbsp;That is, when you call a function, the only significant effect that the function has is usually to compute a value and return it. Of course, behind the scenes the function is using CPU time, allocating and writing memory, but from the programmer's point of view, the primary effect is the return value. &nbsp;Objects in a functional programming language are often immutable that is they were like const , instead of changing an object, you allocate a new object which looks like the old one except for the change. &nbsp;Compare this with an imperative programming language like Java, where progress is made by changing objects' field.</div><div><br /></div><div>In a pure functional language, like Haskell, most functions are guaranteed by the type system not to perform any other actions. &nbsp;In an impure functional language, like ML, a function may have other side effects, such as querying a database or server, generating random numbers, reading or writing the disk, etc.<br /><br /><h3 style="text-align: left;"><span style="color: cyan;">TYPES OF FUNCTIONAL PROGRAMMING:</span></h3></div><div><span style="color: cyan;">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</span>These are different types of functional programming available you dont need to master all but it's necessary to master one among them .List of programming languages available are</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; These are languages typically processed by compilers, though theoretically any language can be compiled or interpreted.</div><div><ul style="text-align: left;"><li>ActionScript</li><li>Ada (multi-purpose language)</li><li>ALGOL (extremely influential language design â€“ the second high level language compiler)</li><li>SMALL Machine Algol Like Language</li><li>Ateji PX, an extension of the Java language for parallelism</li><li>BASIC (some dialects, including the first version of Dartmouth BASIC)</li><li>BCPL</li><li>Blue</li><li>C (one of the most widely used procedural programming languages)</li><li>C++ (One of the most widely used object-oriented (OO) languages specially used in large-scale, highly complex, high-performance software systems)</li><li>C# (compiled into CIL, which generates a native image at runtime)</li><li>Ceylon (compiled into JVM bytecode)</li><li>CHILL</li><li>CLIPPER 5.3 (programming Language for DOS-based software)</li><li>CLEO (Clear Language for Expressing Orders) used the compiler for the British Leo computers</li><li>COBOL</li><li>Cobra</li><li>Common Lisp</li><li>Crystal</li><li>Curl</li><li>D (Attempts a "C++ done right" philosophy)</li><li>DASL compiles into Java, JavaScript, JSP, Flex, etc., which are further compiled into a .war file</li><li>Delphi (Borland's Object Pascal development system)</li><li>DIBOL (Digital Interactive Business Oriented Language)</li><li>Dylan</li><li>eC</li><li>Eiffel (object-oriented language developed by Bertrand Meyer)</li><li>Sather</li><li>Ubercode</li><li>Emacs Lisp</li><li>Erlang</li><li>F# (compiled into CIL, which generates a native image at runtime)</li><li>Factor</li><li>Forth (professional systems, like VFX and SwiftForth)</li><li>Fortran (the first high-level, compiled language, from IBM, John Backus, et al.)</li><li>GAUSS</li><li>Go</li><li>Gosu (compiled into JVM bytecode)</li><li>Groovy (compiled into JVM bytecode)</li><li>Haskell</li><li>Harbour</li><li>Java (usually compiled into JVM bytecode although ahead-of-time (AOT) compilers exist that compile to machine code)</li><li>JOVIAL</li><li>LabVIEW</li><li>Mercury</li><li>Nemerle (compiled into intermediate language bytecode)</li><li>Nim</li><li>Objective-C</li><li>P</li><li>Pascal (most implementations)</li><li>Plus</li><li>Python (compiled into intermediate Virtual Machine bytecode)</li><li>RPG (Report Program Generator)</li><li>Rust</li><li>Scala (compiled into JVM bytecode)</li><li>Scheme (some implementations, e.g. Gambit)</li><li>SequenceL â€“ purely functional, automatically parallelizing and race-free</li><li>Simula (the first object-oriented language, developed by Ole-Johan Dahl and Kristen Nygaard)</li><li>Smalltalk generally compiled to platform independent bytecode that runs on a Virtual Machine</li><li>Swift</li><li>ML</li><li>Standard ML (SML)</li><li>Alice</li><li>OCaml</li><li>Turing</li><li>Vala (Compiler for the GObject type system)</li><li>Visual Basic (Earlier versions compiled directly to a native runtime. Recent .NET versions compile into CIL that is just-in-time compiled into a native image at runtime.)</li><li>Visual FoxPro</li><li>Visual Prolog</li><li>X++</li><li>X#</li><li>XL</li><li>Z++</li></ul><h3 style="text-align: left;"><span style="color: cyan;">BENEFITS :</span></h3></div><div><span style="color: cyan;">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</span>It tends to make a program into much less typing but much more &nbsp;thinking than imperative code. Even if the language itself is very &nbsp;verbose, using its functional paradigm can save a lot on lines of code, &nbsp;but tends to mean the programmer needs to step back and figure out what &nbsp;to do.</div><div><br /></div><div>Some of those features allow for much more optimal execution (i.e. faster and less RAM) than using imperative. Just think about lazy eval ... it means the program responds even before it's calculated all the values and thus also doesn't need to store all those values at once (only those which are in use at this moment).</div><div><br /></div><div>Some of the features means that multi-threading is much simpler to implement. E.g. since there's no side-effects any 2 iterations can be assured that there's no difference in states of their inputs - thus allowing them to happen at the same time or in different orders.</div><div><br /></div><h3 style="text-align: left;"><span style="color: cyan;">FLAWS:</span></h3><div><span style="color: cyan;">&nbsp; &nbsp; &nbsp;</span><b>&nbsp; Performance&nbsp;</b></div><div>A big problem is with predictable performance. This means that most functional languages are not particularly good choices for soft or hard realtime systems or embedded computing.</div><div><br /></div><div>There are a few reasons for this, like higher reliance on garbage collection as well as different evaluation models (ie laziness).&nbsp;</div><div><br /></div><div><b>&nbsp; &nbsp; &nbsp; Garbage Collection</b></div><div>Functional languages, by their very nature, tend to generate larger amounts of short-lived garbage than imperative languages do. While their garbage collectors tend to be optimized for this use profile, it still makes predicting and controlling performance more difficult.</div><div><br /></div><div>&nbsp; &nbsp; &nbsp; <b>&nbsp;Laziness</b></div><div>Laziness is an issue for predictable performance because it moves evaluationâ€”ie the actual computational costâ€”from the place where a computation is defined to where its used. This makes the performance model of a lazy language less compositional.&nbsp;</div><div><br /></div><div><br /></div><div>These were all about functional programming hope this could be useful for you guys ,stay tunned for the further updates until then bye from you guysðŸ‘‹ðŸ‘‹ðŸ‘‹ðŸ‘‹ðŸ‘‹</div></div>